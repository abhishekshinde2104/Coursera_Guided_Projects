#IMPORTING LIBRARIES
#%matplotlib inline

import os
import numpy as np
import tensorflow as tf

from PIL import Image
from matplotlib import pyplot as plt

print('Using TensorFlow', tf.__version__)

#ROTATION
#This class has lot of functions for data augmentation and we can also do data normalisation with it
generator = tf.keras.preprocessing.image.ImageDataGenerator(rotation_range=40)
#this rotation_range = 40 means our image can be rotated randomly between -40 to +40 with the generator object

image_path = 'images/train/cat/cat.jpg'

plt.imshow(plt.imread(image_path));

#flow_from_directory goes into all folders
x, y = next(generator.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));
#You see the image of size 256x256 and theres sort of an angle

#WIDTH AND HEIGHT SHIFTS
#we can shift the pixels along the horizontal and vertical axis
#we can set this range with tuple or list
#we are explicitly giving the possible values in the list
generator_1 = tf.keras.preprocessing.image.ImageDataGenerator(
    width_shift_range=[-100,-50,0,50,100],
    height_shift_range=[-50,0,50])

#3this code goes in all the images in the specified folder and applies the generator object and its parameters to it
x, y = next(generator_1.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));

#BRIGHTNESS
generator_2 = tf.keras.preprocessing.image.ImageDataGenerator(brightness_range=(0.5,2))
#this tuple gives the range instead of explicitly giving the values like a list

x, y = next(generator_2.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));

#SHEAR TRANSFORMATION
generator_3 = tf.keras.preprocessing.image.ImageDataGenerator(shear_range=40)
#just like rotation shear is also in degrees 
#in shear transformation the bottom coordinates are intact while the top coordinates can move in the shear_range degree

x, y = next(generator_3.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));

#ZOOM
generator_4 = tf.keras.preprocessing.image.ImageDataGenerator(zoom_range=0.5)

x, y = next(generator_4.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));

#CHANNEL SHIFT
generator_5 = tf.keras.preprocessing.image.ImageDataGenerator(channel_shift_range=100)
#this shifts the channel value of any rgb channel in range -100 to 100

x, y = next(generator_5.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));
print(x.mean())#this calculates mean of all pixels in the image
#np.array(Image.open(image_path).mean())
#mean value of original image

#FLIPS
generator_6 = tf.keras.preprocessing.image.ImageDataGenerator(vertical_flip=True,horizontal_flip=True)

x, y = next(generator_6.flow_from_directory('images', batch_size=1))
plt.imshow(x[0].astype('uint8'));

#NORMALISATION
#1)FEATURE-WISE
#Nomalisation can be either featuewise or samplewise
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.cifar10.load_data()
generator_7 = tf.keras.preprocessing.image.ImageDataGenerator(
    featurewise_center=True, # all values will be updated mean value will be reduced
    featurewise_std_normalization=True
)

generator_7.fit(x_train)#this here is done to save the changes made by the generator

x, y = next(generator_7.flow(x_train, y_train, batch_size=1))
print(x.mean(), x.std(), y)#0.058420304 0.59477633 [[5]]
print(x_train.mean())#around 120.707565

#2)SAMPLE-WISE
#here we dont need to fit it to x_train and no need to calculate the std,mean as sampling is done
generator_8 = tf.keras.preprocessing.image.ImageDataGenerator(
    samplewise_center=True,
    samplewise_std_normalization=True
)

x, y = next(generator_8.flow(x_train, y_train, batch_size=1))
print(x.mean(), x.std(), y)#-1.9868216e-08 0.99999994 [[3]] , 

#RESCALING AND PREPROCESSING FUNCTION
generator_9 = tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1.,
    preprocessing_function=tf.keras.applications.mobilenet_v2.preprocess_input
)
#1 way to do normalisation as well with rescale
#preprocessing fucntion take a 3-D Numpy array and returns that only
#just give parameters and it will be applied to every image generated by the generator

x, y = next(generator_9.flow(x_train, y_train, batch_size=1))
print(x.mean(), x.std(), y)#-0.26615605 0.47240233 [[2]]


#TRAINING OUR MODEL
generator_10 = tf.keras.preprocessing.image.ImageDataGenerator(
    preprocessing_function=tf.keras.applications.mobilenet_v2.preprocess_input,
    horizontal_flip=True,
    rotation_range=20
)

#Model
#pass list of layers in the sequential class
#1st layer a 3d to 2d tensor
model=tf.keras.models.Sequential([
    tf.keras.applications.mobilenet_v2.MobileNetV2(
        include_top=False, input_shape=(32,32,3),#shape of all the images in the dataset,
        pooling='avg'
    ),
    tf.keras.layers.Dense(10,activation='softmax')
])

model.compile(loss='sparse_categorical_crossentropy',
             optimizer='adam',
             metrics=['accuracy'])
#loss is set that as we dont use OneHotEncoder and our values will be from 0-9
#using the flow method we can create a data iterator on our image and u pass that iterator as it is in model.fit

_=model.fit(generator_10.flow(x_train,y_train,batch_size=32),
           epochs=1,steps_per_epoch=10)










